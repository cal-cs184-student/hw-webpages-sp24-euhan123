<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c19{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:219.8pt;border-top-color:#000000;border-bottom-style:solid}.c16{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:200.2pt;border-top-color:#000000;border-bottom-style:solid}.c0{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:74.2pt;border-top-color:#000000;border-bottom-style:solid}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c9{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Times New Roman";font-style:normal}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c23{-webkit-text-decoration-skip:none;color:#000000;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-style:normal}.c8{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c25{-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline;text-decoration-skip-ink:none}.c6{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c27{border-spacing:0;border-collapse:collapse;margin-right:auto}.c10{color:#000000;text-decoration:none;vertical-align:baseline;font-style:normal}.c18{font-weight:400;font-size:11pt;font-family:"Arial"}.c3{font-size:14pt;font-family:"Times New Roman";font-weight:400}.c21{font-weight:700;font-size:16pt;font-family:"Times New Roman"}.c26{font-weight:700;font-size:18pt;font-family:"Times New Roman"}.c14{font-weight:700;font-size:12pt;font-family:"Times New Roman"}.c5{font-size:12pt;font-family:"Times New Roman";font-weight:400}.c11{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c24{color:inherit;text-decoration:inherit}.c20{margin-left:36pt;text-indent:36pt}.c7{vertical-align:super}.c12{vertical-align:sub}.c15{height:0pt}.c22{margin-left:36pt}.c13{font-style:italic}.c17{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c11 doc-content"><div><p class="c1"><span class="c10 c18"></span></p></div><p class="c8"><span class="c23 c26">CS 184: Computer Graphics and Imaging, Spring 2024</span></p><p class="c8"><span class="c21 c23">Project 1: Rasterizer</span></p><p class="c8"><span class="c10 c21">Euhan Kim and Natalie Wei</span></p><p class="c1"><span class="c10 c21"></span></p><p class="c8"><span class="c5 c25"><a class="c24" href="https://www.google.com/url?q=https://cal-cs184-student.github.io/hw-webpages-sp24-weinatalie/hw1/index.html&amp;sa=D&amp;source=editors&amp;ust=1708157688637752&amp;usg=AOvVaw3Biob44-gXebbaOYnmdqSA">https://cal-cs184-student.github.io/hw-webpages-sp24-weinatalie/hw1/index.html</a></span></p><p class="c8"><span class="c25 c5"><a class="c24" href="https://www.google.com/url?q=https://cal-cs184-student.github.io/hw-webpages-sp24-euhan123/hw1/index.html&amp;sa=D&amp;source=editors&amp;ust=1708157688637953&amp;usg=AOvVaw1_hPsQlc-SoQ-oTm_5HCwd">https://cal-cs184-student.github.io/hw-webpages-sp24-euhan123/hw1/index.html</a></span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c10 c21">Overview</span></p><p class="c4 c17"><span class="c10 c14"></span></p><p class="c4"><span class="c2">For this assignment, we implemented a rasterizer with features such as triangle rendering, supersampling, hierarchical transforms, and texture mapping. We first rasterized single-color triangles; to combat aliasing, we implemented supersampling for smoother edges. Next, we added support for translating, scaling, and rotating polygons. Finally, we implemented texture mapping with pixel and level sampling to produce complex images. Our final product is a graphics renderer that can take in and display simplified SVGs.</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c10 c21">Section I: Rasterization</span></p><p class="c1"><span class="c10 c14"></span></p><p class="c8"><span class="c9">Task 1: Drawing Single-Color Triangles</span></p><p class="c1"><span class="c10 c14"></span></p><p class="c8"><span class="c14">Walk through how you rasterize triangles in your own words.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c5">To rasterize triangles, we began by finding the minimum and maximum values for the x and y coordinates based on the given vertices. Using these values, we calculated a &ldquo;bounding box&rdquo; around the triangle to decrease the number of points that we needed to iterate through. We used a nested for loop to iterate through this bounding box, checking each point with the three line test </span><span class="c5">from lecture</span><span class="c5">&nbsp;(updated to support vertices ordered clockwise </span><span class="c5 c13">or</span><span class="c2">&nbsp;counterclockwise) to determine if it was inside the triangle or not. If it was, we filled it with a color.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c2">For the three line test, we compute line equations between each pair of vertices and check if the given point lies above or below the lines.</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c3">dX</span><span class="c3 c12">i</span><span class="c3">&nbsp;= X</span><span class="c3 c12">i + 1</span><span class="c3">&nbsp;- X</span><span class="c3 c12">i</span></p><p class="c4"><span class="c3">dY</span><span class="c3 c12">i</span><span class="c3">&nbsp;= Y</span><span class="c3 c12">i + 1</span><span class="c3">&nbsp;- Y</span><span class="c3 c12">i</span></p><p class="c4 c17"><span class="c10 c3"></span></p><p class="c4"><span class="c3">&nbsp;L</span><span class="c3 c12">i</span><span class="c3">(x, y) = -(x - X</span><span class="c3 c12">i</span><span class="c3">)dY</span><span class="c3 c12">i</span><span class="c3">&nbsp;+ (y - Y</span><span class="c3 c12">i</span><span class="c3">)dX</span><span class="c3 c12">i</span></p><p class="c1"><span class="c3 c10"></span></p><p class="c8"><span class="c5">If L(x + 0.5, y + 0.5) &gt;= 0 </span><span class="c5 c13">or</span><span class="c2">&nbsp;if L(x + 0.5, y + 0.5) &lt;= 0 for each side, then the point lies within the triangle.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c10 c14">Explain how your algorithm is no worse than one that checks each sample within the bounding box of the triangle.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c2">We are using a nested for loop to iterate from the minimum x and y values to the maximum x and y values. Instead of having to iterate through the entire frame buffer, we are only sampling points that lie within the bounding box determined by these minimum and maximum values.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c10 c14">Show a png screenshot of basic/test4.svg with the default viewing parameters and with the pixel inspector centered on an interesting part of the scene.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c5">The image below displays the rasterized version of </span><span class="c5 c13">basic/test4.svg</span><span class="c2">. Although the triangles should be smooth and continuous, there are noticeable jaggies throughout as well as some disconnection at the end of the magenta triangle.</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 337.00px; height: 263.63px;"><img alt="" src="images/image17.png" style="width: 341.51px; height: 272.63px; margin-left: -4.51px; margin-top: -4.37px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c10 c14">Extra credit: Explain any special optimizations you did beyond simple bounding box triangle rasterization, with a timing comparison table.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c2">For our optimized implementation, we took the vertices in order from left to right and recorded the minimum and maximum x coordinates. Then, we determined the equations of the three lines that formed the sides of the triangle. Starting from the smallest x coordinate, we found the y coordinate bounds for each half-integer x coordinate based on the corresponding sides of the triangle. Then, we colored the points that were in between the y coordinate bounds.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c2">We only had to carry out around 2 * (x_max - x_min) calculations which is significantly less than the naive implementation which carries out around 3 * (x_max - x_min) * (y_max - y_min) calculations. As seen in the timing comparison table, we were able to speed up the process up to 10 times. </span></p><p class="c1"><span class="c2"></span></p><a id="t.c98cf3e866197bafc734e119ebed339d40230226"></a><a id="t.0"></a><table class="c27"><tr class="c15"><td class="c0" colspan="1" rowspan="1"><p class="c6"><span class="c2">File</span></p></td><td class="c16" colspan="1" rowspan="1"><p class="c6"><span class="c2">Naive implementation (milliseconds)</span></p></td><td class="c19" colspan="1" rowspan="1"><p class="c6"><span class="c2">Optimized implementation (milliseconds)</span></p></td></tr><tr class="c15"><td class="c0" colspan="1" rowspan="1"><p class="c6"><span class="c2">test3.svg</span></p></td><td class="c16" colspan="1" rowspan="1"><p class="c6"><span class="c2">48.204, 48.355, 47.899</span></p><p class="c6 c17"><span class="c2"></span></p><p class="c6"><span class="c2">mean: &#8203;&#8203;48.153</span></p></td><td class="c19" colspan="1" rowspan="1"><p class="c6"><span class="c2">4.862, 4.966, 4.889</span></p><p class="c6 c17"><span class="c2"></span></p><p class="c6"><span class="c2">mean: 4.906</span></p></td></tr><tr class="c15"><td class="c0" colspan="1" rowspan="1"><p class="c6"><span class="c2">test4.svg</span></p></td><td class="c16" colspan="1" rowspan="1"><p class="c6"><span class="c2">3.719, 3.459, 3.593</span></p><p class="c6 c17"><span class="c2"></span></p><p class="c6"><span class="c2">mean: 3.590</span></p></td><td class="c19" colspan="1" rowspan="1"><p class="c6"><span class="c2">0.330, 0.337, 0.399</span></p><p class="c6 c17"><span class="c2"></span></p><p class="c6"><span class="c2">mean: 0.355</span></p></td></tr><tr class="c15"><td class="c0" colspan="1" rowspan="1"><p class="c6"><span class="c2">test5.svg</span></p></td><td class="c16" colspan="1" rowspan="1"><p class="c6"><span class="c2">11.001, 11.379, 10.558</span></p><p class="c6 c17"><span class="c2"></span></p><p class="c6"><span class="c2">mean: 10.979</span></p></td><td class="c19" colspan="1" rowspan="1"><p class="c6"><span class="c2">1.037, 1.043, 1.356</span></p><p class="c6 c17"><span class="c2"></span></p><p class="c6"><span class="c2">mean: 1.145</span></p></td></tr><tr class="c15"><td class="c0" colspan="1" rowspan="1"><p class="c6"><span class="c2">test6.svg</span></p></td><td class="c16" colspan="1" rowspan="1"><p class="c6"><span class="c2">5.840, 5.772, 5.629</span></p><p class="c6 c17"><span class="c2"></span></p><p class="c6"><span class="c2">mean: 5.747</span></p></td><td class="c19" colspan="1" rowspan="1"><p class="c6"><span class="c2">0.687, 0.643, 0.627</span></p><p class="c6 c17"><span class="c2"></span></p><p class="c6"><span class="c2">mean: 0.652</span></p></td></tr></table><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c9">Task 2: Antialiasing by Supersampling</span></p><p class="c1"><span class="c10 c14"></span></p><p class="c8"><span class="c10 c14">Walk through your supersampling algorithm and data structures. Why is supersampling useful? </span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c5">First, we </span><span class="c5">resized</span><span class="c5">&nbsp;the vector </span><span class="c5 c13">sample_buffer</span><span class="c5">&nbsp;to be </span><span class="c5 c13">width * height * sample_rate</span><span class="c5">&nbsp;to se a temporary, higher-resolution framebuffer. Then, we rasterized this resized vector, coloring in pixels that are inside the triangle. This was done by adding in two more for loops, ranging from zero to </span><span class="c5 c13">sqrt(sample_rate)</span><span class="c5">, inside the original rasterization to account for the increased number of pixels. Finally, we downsampled by taking the average color of the </span><span class="c5 c13">sample_rate</span><span class="c5">&nbsp;number of pixels to color the final pixels. To easily find these pixels, we stored the subpixels in the index that would correspond to the original pixel being divided into </span><span class="c5 c13">sample_rate</span><span class="c5">&nbsp;number of subpixels. For example, if </span><span class="c5 c13">sample_rate</span><span class="c5">&nbsp;was 4, the subpixels for the original pixel </span><span class="c5 c13">(0, 0)</span><span class="c5">&nbsp;were stored at </span><span class="c5 c13">(0, 0), (0, 1), (1, 0), </span><span class="c5">and </span><span class="c5 c13">(1, 1)</span><span class="c5">. Supersampling is useful since it allows us to remove aliasing artifacts such as jaggies, as seen in </span><span class="c5 c13">basic/test4.svg</span><span class="c5">. Although supersampling allows us to render smoother lines, it comes with a heavier computational cost.</span></p><p class="c1"><span class="c10 c18"></span></p><p class="c8"><span class="c10 c14">What modifications did you make to the rasterization pipeline in the process? Explain how you used supersampling to antialias your triangles.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c5">To implement supersampling, we resized the vector </span><span class="c5 c13">sample_buffer</span><span class="c5">&nbsp;to be </span><span class="c5 c13">width * height * sample_rate</span><span class="c5">. We also added two additional for loops during</span><span class="c5">&nbsp;rasterization to iterate through the subpixels in the higher resolution image. These for loops were nested within the two original for loops, and ranged from </span><span class="c5 c13">0 </span><span class="c5">to </span><span class="c5 c13">sqrt(sample_rate)</span><span class="c5">. Including these additional for loops allowed us to iterate through every single subpixel, coloring them accordingly. Afterwards, we filled the final pixel with the average color value of the </span><span class="c5 c13">sample_rate</span><span class="c5">&nbsp;number of samples corresponding to the pixel.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c10 c14">Show png screenshots of basic/test4.svg with the default viewing parameters and sample rates 1, 4, and 16 to compare them side-by-side. Position the pixel inspector over an area that showcases the effect dramatically; for example, a very skinny triangle corner. Explain why these results are observed.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 292.50px; height: 220.59px;"><img alt="" src="images/image16.png" style="width: 294.13px; height: 220.59px; margin-left: -0.81px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 292.50px; height: 220.59px;"><img alt="" src="images/image9.png" style="width: 294.25px; height: 220.59px; margin-left: -0.87px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c2"></span></p><p class="c8 c20"><span class="c2">Sampling rate: 1 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sampling rate: 4</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 292.50px; height: 220.59px;"><img alt="" src="images/image11.png" style="width: 297.24px; height: 220.59px; margin-left: -2.37px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c2">Sampling rate: 16</span></p><p class="c4 c17"><span class="c2"></span></p><p class="c8"><span class="c2">We see that there is a noticeable gap towards the corner of the purple triangle in this image when rasterized with sampling rate of 1. In the higher sampling rates, 4 and 16, this corner is colored with lighter purple instead of not being colored. This can be seen as a direct result of supersampling as it created a smoother line for the triangle&rsquo;s corner. Following this, we can see that the image with the sampling rate of 16 has a smoother line towards the corner than that of 4. Instead of the corner being jagged lines, the corner has turned into a gradient that gradually goes from purple to white as it nears the corner.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c10 c14">Extra credit: If you implemented alternative antialiasing methods, describe them and include comparison pictures demonstrating the difference between your method and grid-based supersampling.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c2">In our supersampling implementation, we sampled from the center of each subpixel. To implement jittered sampling, we sampled randomly from each subpixel by adding uniform random jitter to each point. The random jitter was calculated using rand() / (RAND_MAX + 1.0). Jittered sampling is noticeably jagged at lower sampling rates, but looks smoother at higher sampling rates&mdash;at a sampling rate of 16, it is more continuous than supersampling, which contains gaps.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 292.50px; height: 220.59px;"><img alt="" src="images/image10.png" style="width: 296.49px; height: 220.59px; margin-left: -2.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 292.50px; height: 220.59px;"><img alt="" src="images/image2.png" style="width: 294.74px; height: 220.59px; margin-left: -1.12px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c2"></span></p><p class="c8 c20"><span class="c2">Sampling rate: 1 &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sampling rate: 4</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 292.50px; height: 220.59px;"><img alt="" src="images/image3.png" style="width: 295.99px; height: 220.59px; margin-left: -1.75px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 292.50px; height: 220.59px;"><img alt="" src="images/image11.png" style="width: 297.24px; height: 220.59px; margin-left: -2.37px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c2"></span></p><p class="c8 c22"><span class="c2">&nbsp; &nbsp; &nbsp;Sampling rate: 16 (jittered)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sampling rate: 16 (supersampled) </span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c9">Task 3: Transforms</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c14">Create an updated version of svg/transforms/robot.svg with cubeman doing something more interesting, like waving or running. Feel free to change his colors or proportions to suit your creativity. Save your svg file as my_robot.svg in your docs/ directory and show a png screenshot of your rendered drawing in your write-up. Explain what you were trying to do with cubeman in words.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c5">We decided to </span><span class="c5">put cubeman</span><span class="c2">&nbsp;in a ballerina pose. We applied rotation transformations to his left and right arms as well as his right leg; we also edited the translations of these elements to mitigate spacing edits caused by the rotations. Since the cubeman&rsquo;s left and right arms are reflections, their rotation transformations are negatives of each other.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 301.50px; height: 226.56px;"><img alt="" src="images/image13.png" style="width: 302.97px; height: 226.56px; margin-left: -0.73px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 305.61px; height: 226.45px;"><img alt="" src="images/image5.png" style="width: 305.61px; height: 228.34px; margin-left: 0.00px; margin-top: -0.95px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c10 c21">Section II: Sampling</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c9">Task 4: Barycentric coordinates</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c10 c14">Explain barycentric coordinates in your own words and use an image to aid you in your explanation. One idea is to use a svg file that plots a single triangle with one red, one green, and one blue vertex, which should produce a smoothly blended color triangle.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c2">In a barycentric coordinate system, any point in the triangle can be represented with the scalars (alpha, beta, gamma). These scalars are weighted averages based on the point&rsquo;s distance from the vertices in the triangle, and can be calculated as shown:</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c3">alpha = L</span><span class="c3 c12">BC</span><span class="c3">&nbsp;(x, y) / L</span><span class="c3 c12">BC</span><span class="c3">&nbsp;(x</span><span class="c3 c12">A</span><span class="c3">, y</span><span class="c3 c12">A</span><span class="c10 c3">)</span></p><p class="c4"><span class="c3">beta = L</span><span class="c3 c12">CA</span><span class="c3">&nbsp;(x, y) / L</span><span class="c3 c12">CA</span><span class="c3">&nbsp;(x</span><span class="c3 c12">B</span><span class="c3">, y</span><span class="c3 c12">B</span><span class="c10 c3">)</span></p><p class="c4"><span class="c10 c3">gamma = 1 - alpha - beta</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c2">Barycentric coordinates linearly interpolate the values at the vertices, which can be observed in the image below. The triangle has a red vertex, a green vertex, and a blue vertex. The color of each point inside the triangle is a weighted average of red, green, and blue based on how the point is from the respective vertex, creating a smooth color gradation. We convert from (x, y) coordinates to barycentric coordinates as shown:</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c3">(x, y) = alpha * (x</span><span class="c3 c12">0</span><span class="c3">, y</span><span class="c3 c12">0</span><span class="c3">) + beta * (x</span><span class="c3 c12">1</span><span class="c3">, y</span><span class="c3 c12">1</span><span class="c3">) + gamma * (x</span><span class="c3 c12">2</span><span class="c3">, y</span><span class="c3 c12">2</span><span class="c10 c3">)</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c2">Apart from color, we can use barycentric coordinates to interpolate across other properties such as texture. </span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 398.34px; height: 298.76px;"><img alt="" src="images/image7.png" style="width: 400.70px; height: 298.76px; margin-left: -1.18px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4 c17"><span class="c2"></span></p><p class="c8"><span class="c10 c14">Show a png screenshot of svg/basic/test7.svg with default viewing parameters and sample rate 1. If you make any additional images with color gradients, include them.</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 398.34px; height: 298.76px;"><img alt="" src="images/image19.png" style="width: 400.18px; height: 298.76px; margin-left: -0.92px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c9">Task 5: &ldquo;Pixel sampling&rdquo; for texture mapping</span></p><p class="c1"><span class="c10 c14"></span></p><p class="c8"><span class="c10 c14">Explain pixel sampling in your own words and describe how you implemented it to perform texture mapping. Briefly discuss the two different pixel sampling methods, nearest and bilinear.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c5">In pixel sampling, we sample pixels from an image in order to determine the color representation of pixels in another image. To use pixel sampling for texture mapping, we transform the image&rsquo;s (x, y) coordinates to a texture </span><span class="c5">map&rsquo;s</span><span class="c2">&nbsp;(u, v) coordinates and sample the corresponding texels; we set the pixel to the resulting color. In order to convert (x, y) coordinates to (u, v) coordinates, we calculated the point&rsquo;s barycentric coordinates and used them to determine the location of the pixel within the texture triangle. </span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c2">We implemented the nearest neighbor and bilinear sampling methods to determine the color of the pixel. Nearest neighbor sampling takes in the (u, v) coordinates, rounds them to the nearest texel in the texture map, and fills the pixel with the color of this approximated texel. Bilinear sampling takes the four nearest texels in the texture map, linearly interpolates their colors, and fills the pixel with this averaged color. Pixel sampling is especially useful in texture mapping because one screen pixel can correspond to multiple texture map texels.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c10 c14">Check out the svg files in the svg/texmap/ directory. Use the pixel inspector to find a good example of where bilinear sampling clearly defeats nearest sampling. Show and compare four png screenshots using nearest sampling at 1 sample per pixel, nearest sampling at 16 samples per pixel, bilinear sampling at 1 sample per pixel, and bilinear sampling at 16 samples per pixel.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 292.50px; height: 220.59px;"><img alt="" src="images/image4.png" style="width: 297.76px; height: 220.59px; margin-left: -2.63px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 292.50px; height: 220.59px;"><img alt="" src="images/image15.png" style="width: 295.24px; height: 220.59px; margin-left: -1.37px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8 c22"><span class="c2">&nbsp; &nbsp; &nbsp;Sampling rate: 1 (nearest)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; Sampling rate: 16 (nearest) </span></p><p class="c1 c22"><span class="c2"></span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 292.50px; height: 220.59px;"><img alt="" src="images/image6.png" style="width: 293.76px; height: 220.59px; margin-left: -0.63px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 292.50px; height: 220.59px;"><img alt="" src="images/image14.png" style="width: 294.50px; height: 220.59px; margin-left: -1.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8 c22"><span class="c2">&nbsp; &nbsp; &nbsp;Sampling rate: 1 (bilinear)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Sampling rate: 16 (bilinear)</span></p><p class="c1"><span class="c2"></span></p><p class="c1"><span class="c10 c14"></span></p><p class="c8"><span class="c10 c14">Comment on the relative differences. Discuss when there will be a large difference between the two methods and why.</span></p><p class="c1"><span class="c10 c14"></span></p><p class="c8"><span class="c2">Since bilinear sampling takes the average of four samples while nearest neighbor sampling only takes one, bilinear sampling appears to yield smoother results. This is especially noticeable in higher frequency portions of the image, like around the gridlines. Under nearest neighbor sampling, the lines appear sharper but have more gaps and aliasing artifacts; under bilinear sampling, the lines are blurrier but smoother.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c9">Task 6: &ldquo;Level sampling&rdquo; with mipmaps for texture mapping</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c10 c14">Explain level sampling in your own words and describe how you implemented it for texture mapping.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c5">In level sampling, we sample from different levels of a mipmap. Each ascending mipmap level is downsampled and decreases in resolution; we sample from the level whose resolution best approximates the sampling rate. To implement level sampling for texture mapping, we first determined the appropriate mipmap level to sample. We calculated the barycentric coordinates of (x, y), (x + 1, y), and (x, y + 1): </span><span class="c5 c13">&#8203;&#8203;sp.p_uv</span><span class="c5">, </span><span class="c5 c13">sp.p_dx_uv</span><span class="c5">, and </span><span class="c5 c13">sp.p_dy_uv</span><span class="c5">. We used these coordinates to determine the difference vectors </span><span class="c5 c13">sp.p_dx_uv - sp.p_uv</span><span class="c5">&nbsp;and </span><span class="c5 c13">sp.p_dy_uv - sp.p_uv</span><span class="c2">. Finally, we scaled these difference vectors by the height and width of the texture map, and applied the following formulas from lecture: </span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span class="c3">D = log</span><span class="c3 c12">2</span><span class="c10 c3">&nbsp;L</span></p><p class="c4"><span class="c3">L = max(sqrt((du/dx)</span><span class="c3 c7">2</span><span class="c3">&nbsp;+ (dv/dx)</span><span class="c3 c7">2</span><span class="c3">), sqrt((du/dy)</span><span class="c3 c7">2</span><span class="c3 c12">&nbsp;</span><span class="c3">+ (dv/dy)</span><span class="c3 c7">2</span><span class="c10 c3">))</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c5">A larger distance generally corresponds to a higher mipmap level, and a smaller distance a lower mipmap level. </span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c10 c14">You can now adjust your sampling technique by selecting pixel sampling, level sampling, or the number of samples per pixel. Describe the tradeoffs between speed, memory usage, and antialiasing power between the three various techniques.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c2">Since bilinear pixel sampling requires sampling multiple neighbors, it is the slowest of all the pixel sampling techniques. Meanwhile, nearest pixel sampling only requires sampling one pixel, making it the fastest. Level sampling requires us to sample across multiple levels, so while it is not as slow as bilinear sampling, it is not as efficient as nearest pixel sampling. Nearest pixel sampling at level 0 has the fastest overall performance, while bilinear pixel sampling with bilinear level interpolation has the slowest performance. </span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c5">Number of samples per pixel uses the most memory, as it requires a </span><span class="c5 c13">sample_rate</span><span class="c2">&nbsp;amount of iterations. Level 0 also uses more memory than level sampling techniques that utilize mipmaps.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c2">Since bilinear sampling takes the average of four samples, it has the best antialiasing power; nearest neighbor sampling only takes one sample and features more aliasing artifacts. Level sampling takes more samples than nearest neighbor sampling and has better antialiasing, but is still beat out by bilinear sampling. Nearest pixel sampling at level 0 therefore has the worst antialiasing, while bilinear pixel sampling with bilinear level interpolation has the best antialiasing.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c10 c14">Using a png file you find yourself, show us four versions of the image, using the combinations of L_ZERO and P_NEAREST, L_ZERO and P_LINEAR, L_NEAREST and P_NEAREST, as well as L_NEAREST and P_LINEAR.</span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span class="c2">Our chosen image:</span></p><p class="c1"><span class="c2"></span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 381.50px; height: 285.70px;"><img alt="" src="images/image8.png" style="width: 381.50px; height: 285.70px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c2"></span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 292.50px; height: 220.59px;"><img alt="" src="images/image20.png" style="width: 295.61px; height: 220.59px; margin-left: -1.56px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 292.50px; height: 220.59px;"><img alt="" src="images/image12.png" style="width: 297.48px; height: 220.59px; margin-left: -2.49px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8 c22"><span class="c2">&nbsp; &nbsp;L_ZERO and P_NEAREST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; L_ZERO and P_LINEAR</span></p><p class="c1 c22"><span class="c2"></span></p><p class="c8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 292.50px; height: 220.59px;"><img alt="" src="images/image18.png" style="width: 295.61px; height: 220.59px; margin-left: -1.56px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 292.50px; height: 220.59px;"><img alt="" src="images/image1.png" style="width: 296.12px; height: 220.59px; margin-left: -1.81px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c8"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;L_NEAREST and P_NEAREST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; L_NEAREST and P_LINEAR</span></p></body></html>